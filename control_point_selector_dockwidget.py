# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ControlPointsSelectorDockWidget
                                 A QGIS plugin
 Позволяет определить точки отбора проб на основе погодных условий.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-02-05
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Muhametov Danil
        email                : seemsclever@mail.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import requests

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsProject, QgsFeatureRequest, QgsMapLayer, QgsFeature, QgsGeometry, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsPointXY
from qgis.gui import QgsMapToolPan

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'control_point_selector_dockwidget_base.ui'))

class ControlPointsSelectorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, iface=None):
        """Constructor."""
        super(ControlPointsSelectorDockWidget, self).__init__(parent)
        self.iface = iface  # Сохраняем ссылку на iface
        self.setupUi(self)

        # Проверка наличия необходимых элементов UI
        if not hasattr(self, 'comboBox_objectNumber'):
            raise AttributeError("comboBox_objectNumber not found in the UI")

        # Настройка comboBox
        self.comboBox_objectNumber.addItem("Выберите объект", None)
        self.comboBox_objectNumber.setCurrentIndex(0)

        self.fillComboBox()
        # Подключаем сигнал изменения текущего элемента comboBox к обработчику
        self.comboBox_objectNumber.currentIndexChanged.connect(self.onComboBoxChanged)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def fillComboBox(self):
        layer = QgsProject.instance().mapLayersByName("Площадки")[0]
        if layer is not None:
            features = layer.getFeatures(QgsFeatureRequest())
            for feature in features:
                object_number = feature["objectNumber"]
                self.comboBox_objectNumber.addItem(object_number)  # Добавляем только objectNumber

    def onComboBoxChanged(self, index):
        selected_object_number = self.comboBox_objectNumber.currentText()

        layers = QgsProject.instance().mapLayersByName("Площадки")
        if not layers:
            QtWidgets.QMessageBox.warning(self, "Ошибка", "Слой 'Площадки' не найден.")
            return

        layer = layers[0]

        # Ищем feature по objectNumber
        request = QgsFeatureRequest().setFilterExpression(f"objectNumber = '{selected_object_number}'")
        feature = next(layer.getFeatures(request), None)

        if feature and feature.isValid():
            self.iface.mapCanvas().setExtent(feature.geometry().boundingBox())
            self.iface.mapCanvas().refresh()
            layer.selectByIds([feature.id()])

            centroid = feature.geometry().centroid().asPoint()
            latitude, longitude = self.convert_coordinates(centroid.x(), centroid.y(), "EPSG:3857", "EPSG:4326")

            self.getWeatherDataFromOWM(latitude, longitude)
        else:
            self.clearWeatherInfo()

    def getWeatherDataFromOWM(self, lat, lon):
        api_key = '9834faa608479f5b1145b430a7981504'
        url = f"http://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={api_key}&units=metric&lang=ru"
        print(url)

        try:
            response = requests.get(url)
            if response.status_code == 200:
                data = response.json()

                temperature = data['main']['temp']
                wind_speed = data['wind']['speed']
                wind_direction = self.getWindDirection(data['wind']['deg'])

                # Формируем строку с информацией о погоде
                weather_info = f"Температура: {temperature}°C\nСкорость ветра: {wind_speed} м/с\nНаправление ветра: {wind_direction}"
                self.label_weather_OWM.setText(weather_info)

                # Получаем направление ветра из API
                self.current_wind_direction = wind_direction

                # Получаем точки контроля для выбранного объекта
                self.getControlPointsForObject()

            else:
                self.clearWeatherInfo()
                self.label_weather_OWM.setText("Ошибка получения данных о погоде.")
        except Exception as e:
            print(f"Ошибка: {str(e)}")
            self.label_weather_OWM.setText("Ошибка получения данных о погоде.")

    def getControlPointsForObject(self):
        selected_object_number = self.comboBox_objectNumber.currentText()

        control_points_layer = QgsProject.instance().mapLayersByName("Точки контроля")[0]
        if not control_points_layer:
            QtWidgets.QMessageBox.warning(self, "Ошибка", "Слой 'Точки контроля' не найден.")
            return

        expression = f"numberOfObject = '{selected_object_number}'"
        features = control_points_layer.getFeatures(QgsFeatureRequest().setFilterExpression(expression))

        suitable_control_points = []
        suitable_feature_ids = []  # Список для хранения ID подходящих точек
        for feature in features:
            allowed_wind_directions = feature["windDirections"].split(", ")
            if self.current_wind_direction in allowed_wind_directions:
                # Формируем строку с информацией о точке
                point_info = f"Контрольная точка {feature['controlPointNumber']}({feature['numberOfObject']}, {feature['windDirections']})"
                suitable_control_points.append(point_info)
                suitable_feature_ids.append(feature.id())  # Добавляем ID подходящей точки

        # Обновляем label с информацией о подходящих точках
        if suitable_control_points:
            self.label_controlPoints.setText("Подходящие точки контроля:\n" + "\n".join(suitable_control_points))
        else:
            self.label_controlPoints.setText("Подходящие точки контроля не найдены.")

        # Выделяем подходящие точки на карте
        if suitable_feature_ids:
            control_points_layer.selectByIds(suitable_feature_ids)
        else:
            control_points_layer.removeSelection()  # Снимаем выделение, если подходящих точек нет

        print(suitable_control_points)

    def getWindDirection(self, degree):
        directions = ['С', 'СВ', 'В', 'ЮВ', 'Ю', 'ЮЗ', 'З', 'СЗ']
        idx = int((degree + 22.5) // 45) % 8
        return directions[idx]

    def clearWeatherInfo(self):
        """Очищает информацию о погоде при ошибках или отсутствии выбора."""
        self.label_temperature_OWM.setText("Температура: -")
        self.label_windSpeed_OWM.setText("Скорость ветра: -")
        self.label_windDirection_OWM.setText("Направление ветра: -")

    def convert_coordinates(self, x, y, source_crs_epsg, target_crs_epsg):
        """
        Преобразует координаты из одной СК в другую.

        :param x: Координата X (например, восточная координата)
        :param y: Координата Y (например, северная координата)
        :param source_crs_epsg: EPSG код исходной системы координат
        :param target_crs_epsg: EPSG код целевой системы координат
        :return: Преобразованные координаты (широта, долгота)
        """
        # Получаем систему координат источника и назначения
        crs_source = QgsCoordinateReferenceSystem(source_crs_epsg)
        crs_target = QgsCoordinateReferenceSystem(target_crs_epsg)

        # Создаем трансформатор координат
        transform = QgsCoordinateTransform(crs_source, crs_target, QgsProject.instance())

        # Преобразуем координаты
        point = QgsPointXY(x, y)
        transformed_point = transform.transform(point)

        # Возвращаем преобразованные координаты
        return transformed_point.y(), transformed_point.x()  # Возвращаем широту и долготу
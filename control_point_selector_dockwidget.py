# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ControlPointsSelectorDockWidget
                                 A QGIS plugin
 Позволяет определить точки отбора проб на основе погодных условий.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-02-05
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Muhametov Danil
        email                : seemsclever@mail.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import requests

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsProject, QgsFeatureRequest, QgsMapLayer, QgsFeature, QgsGeometry, QgsCoordinateReferenceSystem, \
    QgsCoordinateTransform, QgsPointXY, QgsRectangle
from qgis.gui import QgsMapToolPan

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'control_point_selector_dockwidget_base.ui'))

class ControlPointsSelectorDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None, iface=None):
        """Constructor."""
        super(ControlPointsSelectorDockWidget, self).__init__(parent)
        self.iface = iface  # Сохраняем ссылку на iface
        self.setupUi(self)

        # Проверка наличия необходимых элементов UI
        if not hasattr(self, 'comboBox_objectNumber'):
            raise AttributeError("comboBox_objectNumber not found in the UI")

        self.clearWeather()

        # Настройка comboBox
        self.comboBox_objectNumber.addItem("Выберите объект", None)
        self.comboBox_objectNumber.setCurrentIndex(0)

        self.fillComboBox()
        # Подключаем сигнал изменения текущего элемента comboBox к обработчику
        self.comboBox_objectNumber.currentIndexChanged.connect(self.onComboBoxChanged)

        # Подключаем сигнал изменения текущего элемента comboBox_controlPoints к обработчику
        self.comboBox_controlPoints.currentIndexChanged.connect(self.onControlPointChanged)

        self.pushButton_controlPointsMinus.clicked.connect(self.decrement_rides_counter)
        self.pushButton_controlPointsPlus.clicked.connect(self.increment_rides_counter)
        self.pushButton_controlPointsUpdateValue.clicked.connect(self.update_rides_counter_from_spinbox)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def fillComboBox(self):
        layer = QgsProject.instance().mapLayersByName("Площадки")[0]
        if layer is not None:
            features = layer.getFeatures(QgsFeatureRequest())
            for feature in features:
                object_number = feature["objectNumber"]
                self.comboBox_objectNumber.addItem(object_number)  # Добавляем только objectNumber

    def onComboBoxChanged(self, index):
        selected_object_number = self.comboBox_objectNumber.currentText()
        self.spinBox.setValue(0)

        layers = QgsProject.instance().mapLayersByName("Площадки")
        if not layers:
            QtWidgets.QMessageBox.warning(self, "Ошибка", "Слой 'Площадки' не найден.")
            return

        layer = layers[0]

        # Ищем feature по objectNumber
        request = QgsFeatureRequest().setFilterExpression(f"objectNumber = '{selected_object_number}'")
        feature = next(layer.getFeatures(request), None)

        if feature and feature.isValid():
            # Получаем bounding box объекта
            bbox = feature.geometry().boundingBox()

            # Расширяем bounding box на 10%
            expanded_bbox = self.expand_bounding_box(bbox, 0.1)

            # Устанавливаем расширенный bounding box в качестве экстента карты
            self.iface.mapCanvas().setExtent(expanded_bbox)
            self.iface.mapCanvas().refresh()
            layer.selectByIds([feature.id()])

            centroid = feature.geometry().centroid().asPoint()
            latitude, longitude = self.convert_coordinates(centroid.x(), centroid.y(), "EPSG:3857", "EPSG:4326")

            # Отображаем атрибут name в label_nameOfObject
            name = feature["name"]  # Получаем значение атрибута name
            self.label_nameOfObject.setText(name)  # Устанавливаем текст в label_nameOfObject

            self.getWeatherDataFromOWM(latitude, longitude)
        else:
            self.clearWeather()

    def getWeatherDataFromOWM(self, lat, lon):
        api_key = '9834faa608479f5b1145b430a7981504'
        url = f"http://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={api_key}&units=metric&lang=ru"
        print(url)

        try:
            response = requests.get(url)
            if response.status_code == 200:
                data = response.json()

                temperature = data['main']['temp']
                wind_speed = data['wind']['speed']
                wind_direction = self.getWindDirection(data['wind']['deg'], wind_speed)

                # Формируем строку с информацией о погоде
                weather_info = f"Температура: {temperature}°C\nСкорость ветра: {wind_speed} м/с\nНаправление ветра: {wind_direction}"
                self.label_weather_OWM.setText(weather_info)

                # Получаем направление ветра из API
                self.current_wind_direction = wind_direction

                # Получаем точки контроля для выбранного объекта
                self.getControlPointsForObject()

            else:
                self.clearWeather()
                self.label_weather_OWM.setText("Ошибка получения данных о погоде.")
        except Exception as e:
            print(f"Ошибка: {str(e)}")
            self.label_weather_OWM.setText("Ошибка получения данных о погоде.")

    def getControlPointsForObject(self):
        selected_object_number = self.comboBox_objectNumber.currentText()

        control_points_layer = QgsProject.instance().mapLayersByName("Точки контроля")[0]
        if not control_points_layer:
            QtWidgets.QMessageBox.warning(self, "Ошибка", "Слой 'Точки контроля' не найден.")
            return

        expression = f"numberOfObject = '{selected_object_number}'"
        features = control_points_layer.getFeatures(QgsFeatureRequest().setFilterExpression(expression))

        all_control_points = []  # Список для хранения всех точек
        suitable_control_points = []  # Список для хранения подходящих точек
        all_feature_ids = []  # Список для хранения ID всех точек
        suitable_feature_ids = []  # Список для хранения ID подходящих точек

        self.comboBox_controlPoints.clear()  # Очищаем comboBox перед добавлением новых элементов

        for feature in features:
            # Добавляем все точки в comboBox
            point_info = f"Контрольная точка {feature['controlPointNumber']}({feature['numberOfObject']}, {feature['windDirections']})"
            all_control_points.append(point_info)
            all_feature_ids.append(feature.id())

            # Добавляем номер контрольной точки в comboBox
            self.comboBox_controlPoints.addItem(str(feature['controlPointNumber']), feature.id())

            # Проверяем, подходит ли точка под текущее направление ветра
            allowed_wind_directions = feature["windDirections"].split(", ")
            if self.current_wind_direction == "штиль" or self.current_wind_direction in allowed_wind_directions:
                suitable_control_points.append(point_info)
                suitable_feature_ids.append(feature.id())

        # Обновляем label с информацией о подходящих точках
        if suitable_control_points:
            self.label_controlPoints.setText("Подходящие точки контроля:\n" + "\n".join(suitable_control_points))
        else:
            self.label_controlPoints.setText("Подходящие точки контроля не найдены.")

        # Выделяем подходящие точки на карте
        if suitable_feature_ids:
            control_points_layer.selectByIds(suitable_feature_ids)
        else:
            control_points_layer.removeSelection()

    def onControlPointChanged(self, index):
        """Обработчик изменения выбранной контрольной точки."""
        # Получаем ID выбранной контрольной точки
        feature_id = self.comboBox_controlPoints.currentData()
        self.spinBox.setValue(0)

        if feature_id is not None:
            # Получаем слой "Точки контроля"
            control_points_layer = QgsProject.instance().mapLayersByName("Точки контроля")[0]
            if not control_points_layer:
                QtWidgets.QMessageBox.warning(self, "Ошибка", "Слой 'Точки контроля' не найден.")
                return

            # Получаем feature по ID
            feature = control_points_layer.getFeature(feature_id)
            if feature and feature.isValid():
                # Получаем значение атрибута ridesCounter
                rides_counter = feature["ridesCounter"]
                # Обновляем label_pointDescription
                self.label_pointDescription.setText(f"Количество поездок: {rides_counter}")
            else:
                self.label_pointDescription.setText("Информация о точке недоступна.")
        else:
            self.label_pointDescription.setText("Выберите контрольную точку.")

    def decrement_rides_counter(self):
        """Уменьшает ridesCounter на 1 для выбранной точки."""
        self._update_rides_counter(-1)

    def increment_rides_counter(self):
        """Увеличивает ridesCounter на 1 для выбранной точки."""
        self._update_rides_counter(1)

    def _update_rides_counter(self, delta):
        """Общий метод для изменения ridesCounter."""
        feature_id = self.comboBox_controlPoints.currentData()

        if feature_id is None:
            return

        control_points_layer = QgsProject.instance().mapLayersByName("Точки контроля")
        if not control_points_layer:
            QtWidgets.QMessageBox.warning(self, "Ошибка", "Слой 'Точки контроля' не найден.")
            return

        layer = control_points_layer[0]
        feature = layer.getFeature(feature_id)

        if not feature.isValid():
            return

        current_value = feature["ridesCounter"] or 0
        new_value = max(current_value + delta, 0)  # Не допускаем отрицательные значения

        # Вносим изменения в слой
        layer.startEditing()
        layer.changeAttributeValue(feature.id(), layer.fields().lookupField("ridesCounter"), new_value)
        layer.commitChanges()

        # Обновляем отображение информации
        self.onControlPointChanged(self.comboBox_controlPoints.currentIndex())

    def update_rides_counter_from_spinbox(self):
        """Обновляет ridesCounter значением из spinBox."""
        feature_id = self.comboBox_controlPoints.currentData()
        new_value = self.spinBox.value()  # Убедитесь, что имя spinBox совпадает в UI

        if feature_id is None:
            return

        if new_value < 0:
            QtWidgets.QMessageBox.warning(self, "Ошибка", "Значение не может быть отрицательным.")
            return

        control_points_layer = QgsProject.instance().mapLayersByName("Точки контроля")
        if not control_points_layer:
            QtWidgets.QMessageBox.warning(self, "Ошибка", "Слой 'Точки контроля' не найден.")
            return

        layer = control_points_layer[0]
        feature = layer.getFeature(feature_id)

        if not feature.isValid():
            return

        # Вносим изменения
        layer.startEditing()
        layer.changeAttributeValue(feature.id(), layer.fields().lookupField("ridesCounter"), new_value)
        layer.commitChanges()

        # Обновляем отображение
        self.onControlPointChanged(self.comboBox_controlPoints.currentIndex())

    def getWindDirection(self, degree, wind_speed):
        """
        Возвращает направление ветра или "штиль", если скорость ветра меньше 1 м/с.

        :param degree: Направление ветра в градусах (0-360).
        :param wind_speed: Скорость ветра в м/с.
        :return: Направление ветра или "штиль".
        """
        if wind_speed < 1.5:
            return "штиль"
        directions = ['С', 'СВ', 'В', 'ЮВ', 'Ю', 'ЮЗ', 'З', 'СЗ']
        idx = int((degree + 22.5) // 45) % 8
        return directions[idx]

    def clearWeather(self):
        """Очищает информацию о погоде при ошибках или отсутствии выбора."""
        self.label_weather_OWM.setText("Выберите площадку для отображения погоды")
        self.label_controlPoints.setText("Выберите площадку для отображения контрольных точек")
        self.label_pointDescription.setText("Выберите контрольную точку")
        self.label_nameOfObject.setText("Выберите площадку в списке")

    def convert_coordinates(self, x, y, source_crs_epsg, target_crs_epsg):
        """
        Преобразует координаты из одной СК в другую.

        :param x: Координата X (например, восточная координата)
        :param y: Координата Y (например, северная координата)
        :param source_crs_epsg: EPSG код исходной системы координат
        :param target_crs_epsg: EPSG код целевой системы координат
        :return: Преобразованные координаты (широта, долгота)
        """
        # Получаем систему координат источника и назначения
        crs_source = QgsCoordinateReferenceSystem(source_crs_epsg)
        crs_target = QgsCoordinateReferenceSystem(target_crs_epsg)

        # Создаем трансформатор координат
        transform = QgsCoordinateTransform(crs_source, crs_target, QgsProject.instance())

        # Преобразуем координаты
        point = QgsPointXY(x, y)
        transformed_point = transform.transform(point)

        # Возвращаем преобразованные координаты
        return transformed_point.y(), transformed_point.x()  # Возвращаем широту и долготу

    def expand_bounding_box(self, bbox, percentage=0.1):
        """
        Расширяет bounding box на указанный процент.

        :param bbox: Исходный bounding box (QgsRectangle)
        :param percentage: Процент расширения (по умолчанию 10%)
        :return: Расширенный bounding box (QgsRectangle)
        """
        width = bbox.width()
        height = bbox.height()

        # Вычисляем расширение по ширине и высоте
        expand_width = width * percentage
        expand_height = height * percentage

        # Расширяем bounding box
        expanded_bbox = QgsRectangle(
            bbox.xMinimum() - expand_width,
            bbox.yMinimum() - expand_height,
            bbox.xMaximum() + expand_width,
            bbox.yMaximum() + expand_height
        )

        return expanded_bbox